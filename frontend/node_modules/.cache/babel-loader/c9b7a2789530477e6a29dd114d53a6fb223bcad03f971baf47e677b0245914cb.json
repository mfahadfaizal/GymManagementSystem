{"ast":null,"code":"const NAMESPACE = 'ionicons';\nconst BUILD = /* ionicons */{\n  hydratedSelectorName: \"hydrated\",\n  lazyLoad: false,\n  updatable: true\n};\n\n/*\n Stencil Client Platform v4.35.3 | MIT Licensed | https://stenciljs.com\n */\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/client/client-host-ref.ts\nvar getHostRef = ref => {\n  if (ref.__stencil__getHostRef) {\n    return ref.__stencil__getHostRef();\n  }\n  return void 0;\n};\nvar registerHost = (hostElement, cmpMeta) => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: hostElement,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: /* @__PURE__ */new Map()\n  };\n  {\n    hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);\n    hostElement[\"s-p\"] = [];\n    hostElement[\"s-rc\"] = [];\n  }\n  const ref = hostRef;\n  hostElement.__stencil__getHostRef = () => ref;\n  return ref;\n};\nvar isMemberInElement = (elm, memberName) => memberName in elm;\nvar consoleError = (e, el) => (0, console.error)(e, el);\n\n// src/client/client-style.ts\nvar styles = /* @__PURE__ */new Map();\nvar SLOT_FB_CSS = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\";\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\";\nvar win = typeof window !== \"undefined\" ? window : {};\nvar H = win.HTMLElement || class {};\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: \"\",\n  jmp: h2 => h2(),\n  raf: h2 => requestAnimationFrame(h2),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n  ce: (eventName, opts) => new CustomEvent(eventName, opts)\n};\nvar promiseResolve = v => Promise.resolve(v);\nvar supportsConstructableStylesheets = /* @__PURE__ */(() => {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === \"function\";\n  } catch (e) {}\n  return false;\n})();\nvar queuePending = false;\nvar queueDomReads = [];\nvar queueDomWrites = [];\nvar queueTask = (queue, write) => cb => {\n  queue.push(cb);\n  if (!queuePending) {\n    queuePending = true;\n    if (write && plt.$flags$ & 4 /* queueSync */) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\nvar consume = queue => {\n  for (let i2 = 0; i2 < queue.length; i2++) {\n    try {\n      queue[i2](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  queue.length = 0;\n};\nvar flush = () => {\n  consume(queueDomReads);\n  {\n    consume(queueDomWrites);\n    if (queuePending = queueDomReads.length > 0) {\n      plt.raf(flush);\n    }\n  }\n};\nvar nextTick = cb => promiseResolve().then(cb);\nvar writeTask = /* @__PURE__ */queueTask(queueDomWrites, true);\n\n// src/runtime/asset-path.ts\nvar getAssetPath = path => {\n  const assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nvar setAssetPath = path => plt.$resourcesUrl$ = path;\nvar isComplexType = o => {\n  o = typeof o;\n  return o === \"object\" || o === \"function\";\n};\n\n// src/utils/query-nonce-meta-tag-content.ts\nfunction queryNonceMetaTagContent(doc) {\n  var _a, _b, _c;\n  return (_c = (_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) == null ? void 0 : _b.getAttribute(\"content\")) != null ? _c : void 0;\n}\n\n// src/utils/regular-expression.ts\nvar escapeRegExpSpecialCharacters = text => {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\n// src/utils/result.ts\nvar result_exports = {};\n__export(result_exports, {\n  err: () => err,\n  map: () => map,\n  ok: () => ok,\n  unwrap: () => unwrap,\n  unwrapErr: () => unwrapErr\n});\nvar ok = value => ({\n  isOk: true,\n  isErr: false,\n  value\n});\nvar err = value => ({\n  isOk: false,\n  isErr: true,\n  value\n});\nfunction map(result, fn) {\n  if (result.isOk) {\n    const val = fn(result.value);\n    if (val instanceof Promise) {\n      return val.then(newVal => ok(newVal));\n    } else {\n      return ok(val);\n    }\n  }\n  if (result.isErr) {\n    const value = result.value;\n    return err(value);\n  }\n  throw \"should never get here\";\n}\nvar unwrap = result => {\n  if (result.isOk) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\nvar unwrapErr = result => {\n  if (result.isErr) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\n// src/utils/style.ts\nfunction createStyleSheetIfNeededAndSupported(styles2) {\n  return void 0;\n}\n\n// src/utils/shadow-root.ts\nvar globalStyleSheet;\nfunction createShadowRoot(cmpMeta) {\n  var _a;\n  const shadowRoot = this.attachShadow({\n    mode: \"open\"\n  });\n  if (globalStyleSheet === void 0) globalStyleSheet = (_a = createStyleSheetIfNeededAndSupported()) != null ? _a : null;\n  if (globalStyleSheet) shadowRoot.adoptedStyleSheets.push(globalStyleSheet);\n}\nvar createTime = (fnName, tagName = \"\") => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\nvar rootAppliedStyles = /* @__PURE__ */new WeakMap();\nvar registerStyle = (scopeId2, cssText, allowCS) => {\n  let style = styles.get(scopeId2);\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    if (typeof style === \"string\") {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n  styles.set(scopeId2, style);\n};\nvar addStyle = (styleContainerNode, cmpMeta, mode) => {\n  var _a;\n  const scopeId2 = getScopeId(cmpMeta);\n  const style = styles.get(scopeId2);\n  if (!win.document) {\n    return scopeId2;\n  }\n  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : win.document;\n  if (style) {\n    if (typeof style === \"string\") {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */new Set());\n      }\n      if (!appliedStyles.has(scopeId2)) {\n        {\n          styleElm = win.document.createElement(\"style\");\n          styleElm.innerHTML = style;\n          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);\n          if (nonce != null) {\n            styleElm.setAttribute(\"nonce\", nonce);\n          }\n          if (!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */)) {\n            if (styleContainerNode.nodeName === \"HEAD\") {\n              const preconnectLinks = styleContainerNode.querySelectorAll(\"link[rel=preconnect]\");\n              const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector(\"style\");\n              styleContainerNode.insertBefore(styleElm, (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null);\n            } else if (\"host\" in styleContainerNode) {\n              if (supportsConstructableStylesheets) {\n                const stylesheet = new CSSStyleSheet();\n                stylesheet.replaceSync(style);\n                styleContainerNode.adoptedStyleSheets.unshift(stylesheet);\n              } else {\n                const existingStyleContainer = styleContainerNode.querySelector(\"style\");\n                if (existingStyleContainer) {\n                  existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;\n                } else {\n                  styleContainerNode.prepend(styleElm);\n                }\n              }\n            } else {\n              styleContainerNode.append(styleElm);\n            }\n          }\n          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            styleContainerNode.insertBefore(styleElm, null);\n          }\n        }\n        if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {\n          styleElm.innerHTML += SLOT_FB_CSS;\n        }\n        if (appliedStyles) {\n          appliedStyles.add(scopeId2);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets.push(style);\n    }\n  }\n  return scopeId2;\n};\nvar attachStyles = hostRef => {\n  const cmpMeta = hostRef.$cmpMeta$;\n  const elm = hostRef.$hostElement$;\n  const flags = cmpMeta.$flags$;\n  const endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n  const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);\n  if (flags & 10 /* needsScopedEncapsulation */) {\n    elm[\"s-sc\"] = scopeId2;\n    elm.classList.add(scopeId2 + \"-h\");\n  }\n  endAttachStyles();\n};\nvar getScopeId = (cmp, mode) => \"sc-\" + cmp.$tagName$;\nvar h = (nodeName, vnodeData, ...children) => {\n  let child = null;\n  let key = null;\n  let simple = false;\n  let lastSimple = false;\n  const vNodeChildren = [];\n  const walk = c => {\n    for (let i2 = 0; i2 < c.length; i2++) {\n      child = c[i2];\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== \"boolean\") {\n        if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n          child = String(child);\n        }\n        if (simple && lastSimple) {\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n        lastSimple = simple;\n      }\n    }\n  };\n  walk(children);\n  if (vnodeData) {\n    if (vnodeData.key) {\n      key = vnodeData.key;\n    }\n    {\n      const classData = vnodeData.className || vnodeData.class;\n      if (classData) {\n        vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter(k => classData[k]).join(\" \");\n      }\n    }\n  }\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n  {\n    vnode.$key$ = key;\n  }\n  return vnode;\n};\nvar newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  {\n    vnode.$key$ = null;\n  }\n  return vnode;\n};\nvar Host = {};\nvar isHost = node => node && node.$tag$ === Host;\nvar createSupportsRuleRe = selector => {\n  const safeSelector2 = escapeRegExpSpecialCharacters(selector);\n  return new RegExp(\n  // First capture group: match any context before the selector that's not inside @supports selector()\n  // Using negative lookahead to avoid matching inside @supports selector(...) condition\n  `(^|[^@]|@(?!supports\\\\s+selector\\\\s*\\\\([^{]*?${safeSelector2}))(${safeSelector2}\\\\b)`, \"g\");\n};\ncreateSupportsRuleRe(\"::slotted\");\ncreateSupportsRuleRe(\":host\");\ncreateSupportsRuleRe(\":host-context\");\nvar parsePropertyValue = (propValue, propType, isFormAssociated) => {\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4 /* Boolean */) {\n      {\n        return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n      }\n    }\n    if (propType & 1 /* String */) {\n      return String(propValue);\n    }\n    return propValue;\n  }\n  return propValue;\n};\nvar emitEvent = (elm, name, opts) => {\n  const ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\nvar setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {\n  if (oldValue === newValue) {\n    return;\n  }\n  let isProp = isMemberInElement(elm, memberName);\n  let ln = memberName.toLowerCase();\n  if (memberName === \"class\") {\n    const classList = elm.classList;\n    const oldClasses = parseClassList(oldValue);\n    let newClasses = parseClassList(newValue);\n    {\n      classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));\n    }\n  } else if (memberName === \"style\") {\n    {\n      for (const prop in oldValue) {\n        if (!newValue || newValue[prop] == null) {\n          if (prop.includes(\"-\")) {\n            elm.style.removeProperty(prop);\n          } else {\n            elm.style[prop] = \"\";\n          }\n        }\n      }\n    }\n    for (const prop in newValue) {\n      if (!oldValue || newValue[prop] !== oldValue[prop]) {\n        if (prop.includes(\"-\")) {\n          elm.style.setProperty(prop, newValue[prop]);\n        } else {\n          elm.style[prop] = newValue[prop];\n        }\n      }\n    }\n  } else if (memberName === \"key\") ;else if (memberName === \"ref\") {\n    if (newValue) {\n      newValue(elm);\n    }\n  } else if (!elm.__lookupSetter__(memberName) && memberName[0] === \"o\" && memberName[1] === \"n\") {\n    if (memberName[2] === \"-\") {\n      memberName = memberName.slice(3);\n    } else if (isMemberInElement(win, ln)) {\n      memberName = ln.slice(2);\n    } else {\n      memberName = ln[2] + memberName.slice(3);\n    }\n    if (oldValue || newValue) {\n      const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);\n      memberName = memberName.replace(CAPTURE_EVENT_REGEX, \"\");\n      if (oldValue) {\n        plt.rel(elm, memberName, oldValue, capture);\n      }\n      if (newValue) {\n        plt.ael(elm, memberName, newValue, capture);\n      }\n    }\n  } else {\n    const isComplex = isComplexType(newValue);\n    if ((isProp || isComplex && newValue !== null) && true) {\n      try {\n        if (!elm.tagName.includes(\"-\")) {\n          const n = newValue == null ? \"\" : newValue;\n          if (memberName === \"list\") {\n            isProp = false;\n          } else if (oldValue == null || elm[memberName] != n) {\n            if (typeof elm.__lookupSetter__(memberName) === \"function\") {\n              elm[memberName] = n;\n            } else {\n              elm.setAttribute(memberName, n);\n            }\n          }\n        } else if (elm[memberName] !== newValue) {\n          elm[memberName] = newValue;\n        }\n      } catch (e) {}\n    }\n    let xlink = false;\n    {\n      if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n        memberName = ln;\n        xlink = true;\n      }\n    }\n    if (newValue == null || newValue === false) {\n      if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n        if (xlink) {\n          elm.removeAttributeNS(XLINK_NS, memberName);\n        } else {\n          elm.removeAttribute(memberName);\n        }\n      }\n    } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex && elm.nodeType === 1 /* ElementNode */) {\n      newValue = newValue === true ? \"\" : newValue;\n      if (xlink) {\n        elm.setAttributeNS(XLINK_NS, memberName, newValue);\n      } else {\n        elm.setAttribute(memberName, newValue);\n      }\n    }\n  }\n};\nvar parseClassListRegex = /\\s/;\nvar parseClassList = value => {\n  if (typeof value === \"object\" && value && \"baseVal\" in value) {\n    value = value.baseVal;\n  }\n  if (!value || typeof value !== \"string\") {\n    return [];\n  }\n  return value.split(parseClassListRegex);\n};\nvar CAPTURE_EVENT_SUFFIX = \"Capture\";\nvar CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + \"$\");\n\n// src/runtime/vdom/update-element.ts\nvar updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {\n  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};\n  const newVnodeAttrs = newVnode.$attrs$ || {};\n  {\n    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);\n      }\n    }\n  }\n  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {\n    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);\n  }\n};\nfunction sortedAttrNames(attrNames) {\n  return attrNames.includes(\"ref\") ?\n  // we need to sort these to ensure that `'ref'` is the last attr\n  [...attrNames.filter(attr => attr !== \"ref\"), \"ref\"] :\n  // no need to sort, return the original array\n  attrNames;\n}\nvar hostTagName;\nvar isSvgMode = false;\nvar createElm = (oldParentVNode, newParentVNode, childIndex) => {\n  const newVNode2 = newParentVNode.$children$[childIndex];\n  let i2 = 0;\n  let elm;\n  let childNode;\n  if (newVNode2.$text$ !== null) {\n    elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);\n  } else {\n    if (!win.document) {\n      throw new Error(\"You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.\");\n    }\n    elm = newVNode2.$elm$ = win.document.createElement(newVNode2.$tag$);\n    {\n      updateElement(null, newVNode2, isSvgMode);\n    }\n    if (newVNode2.$children$) {\n      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {\n        childNode = createElm(oldParentVNode, newVNode2, i2);\n        if (childNode) {\n          elm.appendChild(childNode);\n        }\n      }\n    }\n  }\n  elm[\"s-hn\"] = hostTagName;\n  return elm;\n};\nvar addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = parentElm;\n  let childNode;\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx);\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        insertBefore(containerElm, childNode, before);\n      }\n    }\n  }\n};\nvar removeVnodes = (vnodes, startIdx, endIdx) => {\n  for (let index = startIdx; index <= endIdx; ++index) {\n    const vnode = vnodes[index];\n    if (vnode) {\n      const elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n      if (elm) {\n        elm.remove();\n      }\n    }\n  }\n};\nvar updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let idxInOld = 0;\n  let i2 = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n  let elmToMove;\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {\n      patch(oldStartVnode, newStartVnode, isInitialRender);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {\n      patch(oldEndVnode, newEndVnode, isInitialRender);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {\n      patch(oldStartVnode, newEndVnode, isInitialRender);\n      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {\n      patch(oldEndVnode, newStartVnode, isInitialRender);\n      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      idxInOld = -1;\n      {\n        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {\n          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {\n            idxInOld = i2;\n            break;\n          }\n        }\n      }\n      if (idxInOld >= 0) {\n        elmToMove = oldCh[idxInOld];\n        if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);\n        } else {\n          patch(elmToMove, newStartVnode, isInitialRender);\n          oldCh[idxInOld] = void 0;\n          node = elmToMove.$elm$;\n        }\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);\n        newStartVnode = newCh[++newStartIdx];\n      }\n      if (node) {\n        {\n          insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\nvar isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    if (!isInitialRender) {\n      return leftVNode.$key$ === rightVNode.$key$;\n    }\n    if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {\n      leftVNode.$key$ = rightVNode.$key$;\n    }\n    return true;\n  }\n  return false;\n};\nvar patch = (oldVNode, newVNode2, isInitialRender = false) => {\n  const elm = newVNode2.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode2.$children$;\n  const text = newVNode2.$text$;\n  if (text === null) {\n    {\n      updateElement(oldVNode, newVNode2, isSvgMode);\n    }\n    if (oldChildren !== null && newChildren !== null) {\n      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);\n    } else if (newChildren !== null) {\n      if (oldVNode.$text$ !== null) {\n        elm.textContent = \"\";\n      }\n      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);\n    } else if (\n    // don't do this on initial render as it can cause non-hydrated content to be removed\n    !isInitialRender && BUILD.updatable && oldChildren !== null) {\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    } else ;\n  } else if (oldVNode.$text$ !== text) {\n    elm.data = text;\n  }\n};\nvar nullifyVNodeRefs = vNode => {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\nvar insertBefore = (parent, newNode, reference) => {\n  {\n    return parent == null ? void 0 : parent.insertBefore(newNode, reference);\n  }\n};\nvar renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {\n  const hostElm = hostRef.$hostElement$;\n  const cmpMeta = hostRef.$cmpMeta$;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const isHostElement = isHost(renderFnResults);\n  const rootVnode = isHostElement ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n  if (cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);\n  }\n  if (isInitialLoad && rootVnode.$attrs$) {\n    for (const key of Object.keys(rootVnode.$attrs$)) {\n      if (hostElm.hasAttribute(key) && ![\"key\", \"ref\", \"style\", \"class\"].includes(key)) {\n        rootVnode.$attrs$[key] = hostElm[key];\n      }\n    }\n  }\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4 /* isHost */;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;\n  patch(oldVNode, rootVnode, isInitialLoad);\n};\n\n// src/runtime/update-component.ts\nvar attachToAncestor = (hostRef, ancestorComponent) => {\n  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n    const index = ancestorComponent[\"s-p\"].push(new Promise(r => hostRef.$onRenderResolve$ = () => {\n      ancestorComponent[\"s-p\"].splice(index - 1, 1);\n      r();\n    }));\n  }\n};\nvar scheduleUpdate = (hostRef, isInitialLoad) => {\n  {\n    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n  }\n  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n    hostRef.$flags$ |= 512 /* needsRerender */;\n    return;\n  }\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n  return writeTask(dispatch);\n};\nvar dispatchHooks = (hostRef, isInitialLoad) => {\n  const elm = hostRef.$hostElement$;\n  const endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n  const instance = elm;\n  if (!instance) {\n    throw new Error(`Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \\`externalRuntime: true\\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);\n  }\n  let maybePromise;\n  if (isInitialLoad) {\n    maybePromise = safeCall(instance, \"componentWillLoad\", void 0, elm);\n  } else {\n    maybePromise = safeCall(instance, \"componentWillUpdate\", void 0, elm);\n  }\n  maybePromise = enqueue(maybePromise, () => safeCall(instance, \"componentWillRender\", void 0, elm));\n  endSchedule();\n  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nvar enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch(err2 => {\n  console.error(err2);\n  fn();\n}) : fn();\nvar isPromisey = maybePromise => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === \"function\";\nvar updateComponent = async (hostRef, instance, isInitialLoad) => {\n  var _a;\n  const elm = hostRef.$hostElement$;\n  const endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n  const rc = elm[\"s-rc\"];\n  if (isInitialLoad) {\n    attachStyles(hostRef);\n  }\n  const endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n  {\n    callRender(hostRef, instance, elm, isInitialLoad);\n  }\n  if (rc) {\n    rc.map(cb => cb());\n    elm[\"s-rc\"] = void 0;\n  }\n  endRender();\n  endUpdate();\n  {\n    const childrenPromises = (_a = elm[\"s-p\"]) != null ? _a : [];\n    const postUpdate = () => postUpdateComponent(hostRef);\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n      childrenPromises.length = 0;\n    }\n  }\n};\nvar callRender = (hostRef, instance, elm, isInitialLoad) => {\n  try {\n    instance = instance.render();\n    {\n      hostRef.$flags$ &= -17 /* isQueuedForUpdate */;\n    }\n    {\n      hostRef.$flags$ |= 2 /* hasRendered */;\n    }\n    {\n      {\n        {\n          renderVdom(hostRef, instance, isInitialLoad);\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n  return null;\n};\nvar postUpdateComponent = hostRef => {\n  const tagName = hostRef.$cmpMeta$.$tagName$;\n  const elm = hostRef.$hostElement$;\n  const endPostUpdate = createTime(\"postUpdate\", tagName);\n  const instance = elm;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  safeCall(instance, \"componentDidRender\", void 0, elm);\n  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n    hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n    {\n      addHydratedFlag(elm);\n    }\n    safeCall(instance, \"componentDidLoad\", void 0, elm);\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    safeCall(instance, \"componentDidUpdate\", void 0, elm);\n    endPostUpdate();\n  }\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = void 0;\n    }\n    if (hostRef.$flags$ & 512 /* needsRerender */) {\n      nextTick(() => scheduleUpdate(hostRef, false));\n    }\n    hostRef.$flags$ &= -517;\n  }\n};\nvar appDidLoad = who => {\n  nextTick(() => emitEvent(win, \"appload\", {\n    detail: {\n      namespace: NAMESPACE\n    }\n  }));\n};\nvar safeCall = (instance, method, arg, elm) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e, elm);\n    }\n  }\n  return void 0;\n};\nvar addHydratedFlag = elm => {\n  var _a;\n  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : \"hydrated\");\n};\n\n// src/runtime/set-value.ts\nvar getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nvar setValue = (ref, propName, newVal, cmpMeta) => {\n  const hostRef = getHostRef(ref);\n  const elm = ref;\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = elm;\n  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  const didValueChange = newVal !== oldVal && !areBothNaN;\n  if (didValueChange) {\n    hostRef.$instanceValues$.set(propName, newVal);\n    {\n      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n        const watchMethods = cmpMeta.$watchers$[propName];\n        if (watchMethods) {\n          watchMethods.map(watchMethodName => {\n            try {\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n        if (instance.componentShouldUpdate) {\n          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n            return;\n          }\n        }\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n};\n\n// src/runtime/proxy-component.ts\nvar proxyComponent = (Cstr, cmpMeta, flags) => {\n  var _a, _b;\n  const prototype = Cstr.prototype;\n  if (cmpMeta.$members$ || cmpMeta.$watchers$ || Cstr.watchers) {\n    if (Cstr.watchers && !cmpMeta.$watchers$) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});\n    members.map(([memberName, [memberFlags]]) => {\n      if (memberFlags & 31 /* Prop */ || memberFlags & 32 /* State */) {\n        const {\n          get: origGetter,\n          set: origSetter\n        } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};\n        if (origGetter) cmpMeta.$members$[memberName][0] |= 2048 /* Getter */;\n        if (origSetter) cmpMeta.$members$[memberName][0] |= 4096 /* Setter */;\n        {\n          Object.defineProperty(prototype, memberName, {\n            get() {\n              {\n                return origGetter ? origGetter.apply(this) : getValue(this, memberName);\n              }\n            },\n            configurable: true,\n            enumerable: true\n          });\n        }\n        Object.defineProperty(prototype, memberName, {\n          set(newValue) {\n            const ref = getHostRef(this);\n            if (origSetter) {\n              const currentValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              if (typeof currentValue === \"undefined\" && ref.$instanceValues$.get(memberName)) {\n                newValue = ref.$instanceValues$.get(memberName);\n              } else if (!ref.$instanceValues$.get(memberName) && currentValue) {\n                ref.$instanceValues$.set(memberName, currentValue);\n              }\n              origSetter.apply(this, [parsePropertyValue(newValue, memberFlags)]);\n              newValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n            {\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n          }\n        });\n      }\n    });\n    {\n      const attrNameToPropName = /* @__PURE__ */new Map();\n      prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {\n        plt.jmp(() => {\n          var _a2;\n          const propName = attrNameToPropName.get(attrName);\n          if (this.hasOwnProperty(propName) && BUILD.lazyLoad) ;else if (prototype.hasOwnProperty(propName) && typeof this[propName] === \"number\" &&\n          // cast type to number to avoid TS compiler issues\n          this[propName] == newValue) {\n            return;\n          } else if (propName == null) {\n            const hostRef = getHostRef(this);\n            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;\n            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {\n              const elm = this;\n              const instance = elm;\n              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];\n              entry == null ? void 0 : entry.forEach(callbackName => {\n                if (instance[callbackName] != null) {\n                  instance[callbackName].call(instance, newValue, oldValue, attrName);\n                }\n              });\n            }\n            return;\n          }\n          const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);\n          newValue = newValue === null && typeof this[propName] === \"boolean\" ? false : newValue;\n          if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {\n            this[propName] = newValue;\n          }\n        });\n      };\n      Cstr.observedAttributes = Array.from(/* @__PURE__ */new Set([...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}), ...members.filter(([_, m]) => m[0] & 15 /* HasAttribute */).map(([propName, m]) => {\n        var _a2;\n        const attrName = m[1] || propName;\n        attrNameToPropName.set(attrName, propName);\n        if (m[0] & 512 /* ReflectAttr */) {\n          (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);\n        }\n        return attrName;\n      })]));\n    }\n  }\n  return Cstr;\n};\n\n// src/runtime/initialize-component.ts\nvar initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {\n  let Cstr;\n  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n    hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n    {\n      Cstr = elm.constructor;\n      const cmpTag = elm.localName;\n      customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);\n    }\n    if (Cstr && Cstr.style) {\n      let style;\n      if (typeof Cstr.style === \"string\") {\n        style = Cstr.style;\n      }\n      const scopeId2 = getScopeId(cmpMeta);\n      if (!styles.has(scopeId2)) {\n        const endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n        endRegisterStyles();\n      }\n    }\n  }\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  const schedule = () => scheduleUpdate(hostRef, true);\n  if (ancestorComponent && ancestorComponent[\"s-rc\"]) {\n    ancestorComponent[\"s-rc\"].push(schedule);\n  } else {\n    schedule();\n  }\n};\nvar fireConnectedCallback = (instance, elm) => {};\n\n// src/runtime/connected-callback.ts\nvar connectedCallback = elm => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    const cmpMeta = hostRef.$cmpMeta$;\n    const endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n      hostRef.$flags$ |= 1 /* hasConnected */;\n      {\n        let ancestorComponent = elm;\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          if (ancestorComponent[\"s-p\"]) {\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n      if (BUILD.initializeNextTick) {\n        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n      } else {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) ;else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n        hostRef.$onReadyPromise$.then(() => fireConnectedCallback());\n      }\n    }\n    endConnected();\n  }\n};\nvar disconnectedCallback = async elm => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    getHostRef(elm);\n  }\n  if (rootAppliedStyles.has(elm)) {\n    rootAppliedStyles.delete(elm);\n  }\n  if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {\n    rootAppliedStyles.delete(elm.shadowRoot);\n  }\n};\nvar proxyCustomElement = (Cstr, compactMeta) => {\n  const cmpMeta = {\n    $flags$: compactMeta[0],\n    $tagName$: compactMeta[1]\n  };\n  {\n    cmpMeta.$members$ = compactMeta[2];\n  }\n  {\n    cmpMeta.$watchers$ = Cstr.$watchers$;\n  }\n  {\n    cmpMeta.$attrsToReflect$ = [];\n  }\n  const originalConnectedCallback = Cstr.prototype.connectedCallback;\n  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n  Object.assign(Cstr.prototype, {\n    __hasHostListenerAttached: false,\n    __registerHost() {\n      registerHost(this, cmpMeta);\n    },\n    connectedCallback() {\n      if (!this.__hasHostListenerAttached) {\n        getHostRef(this);\n        this.__hasHostListenerAttached = true;\n      }\n      connectedCallback(this);\n      if (originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    },\n    disconnectedCallback() {\n      disconnectedCallback(this);\n      if (originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    },\n    __attachShadow() {\n      {\n        if (!this.shadowRoot) {\n          createShadowRoot.call(this, cmpMeta);\n        } else {\n          if (this.shadowRoot.mode !== \"open\") {\n            throw new Error(`Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`);\n          }\n        }\n      }\n    }\n  });\n  Cstr.is = cmpMeta.$tagName$;\n  return proxyComponent(Cstr, cmpMeta);\n};\n\n// src/runtime/nonce.ts\nvar setNonce = nonce => plt.$nonce$ = nonce;\n\n// src/runtime/platform-options.ts\nvar setPlatformOptions = opts => Object.assign(plt, opts);\n\n// src/runtime/render.ts\nfunction render(vnode, container) {\n  const cmpMeta = {\n    $flags$: 0,\n    $tagName$: container.tagName\n  };\n  const ref = {\n    $cmpMeta$: cmpMeta,\n    $hostElement$: container\n  };\n  renderVdom(ref, vnode);\n}\nlet CACHED_MAP;\nconst getIconMap = () => {\n  if (typeof window === 'undefined') {\n    return new Map();\n  } else {\n    if (!CACHED_MAP) {\n      const win = window;\n      win.Ionicons = win.Ionicons || {};\n      CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n    }\n    return CACHED_MAP;\n  }\n};\nconst addIcons = icons => {\n  Object.keys(icons).forEach(name => {\n    addToIconMap(name, icons[name]);\n    /**\n     * Developers can also pass in the SVG object directly\n     * and Ionicons can map the object to a kebab case name.\n     * Example: addIcons({ addCircleOutline });\n     * This will create an \"addCircleOutline\" entry and\n     * an \"add-circle-outline\" entry.\n     * Usage: <ion-icon name=\"add-circle-outline\"></ion-icon>\n     * Using name=\"addCircleOutline\" is valid too, but the\n     * kebab case naming is preferred.\n     */\n    const toKebabCase = name.replace(/([a-z0-9]|(?=[A-Z]))([A-Z0-9])/g, '$1-$2').toLowerCase();\n    if (name !== toKebabCase) {\n      addToIconMap(toKebabCase, icons[name]);\n    }\n  });\n};\nconst addToIconMap = (name, data) => {\n  const map = getIconMap();\n  const existingIcon = map.get(name);\n  if (existingIcon === undefined) {\n    map.set(name, data);\n    /**\n     * Importing and defining the same icon reference\n     * multiple times should not yield a warning.\n     */\n  } else if (existingIcon !== data) {\n    console.warn(`[Ionicons Warning]: Multiple icons were mapped to name \"${name}\". Ensure that multiple icons are not mapped to the same icon name.`);\n  }\n};\nconst getUrl = i => {\n  let url = getSrc(i.src);\n  if (url) {\n    return url;\n  }\n  url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n  if (url) {\n    return getNamedUrl(url, i);\n  }\n  if (i.icon) {\n    url = getSrc(i.icon);\n    if (url) {\n      return url;\n    }\n    url = getSrc(i.icon[i.mode]);\n    if (url) {\n      return url;\n    }\n  }\n  return null;\n};\nconst getNamedUrl = (iconName, iconEl) => {\n  const url = getIconMap().get(iconName);\n  if (url) {\n    return url;\n  }\n  try {\n    return getAssetPath(`svg/${iconName}.svg`);\n  } catch (e) {\n    console.log('e', e);\n    /**\n     * In the custom elements build version of ionicons, referencing an icon\n     * by name will throw an invalid URL error because the asset path is not defined.\n     * This catches that error and logs something that is more developer-friendly.\n     * We also include a reference to the ion-icon element so developers can\n     * figure out which instance of ion-icon needs to be updated.\n     */\n    console.warn(`[Ionicons Warning]: Could not load icon with name \"${iconName}\". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.`, iconEl);\n  }\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n  // default to \"md\" if somehow the mode wasn't set\n  mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n  // if an icon was passed in using the ios or md attributes\n  // set the iconName to whatever was passed in\n  if (ios && mode === 'ios') {\n    iconName = toLower(ios);\n  } else if (md && mode === 'md') {\n    iconName = toLower(md);\n  } else {\n    if (!iconName && icon && !isSrc(icon)) {\n      iconName = icon;\n    }\n    if (isStr(iconName)) {\n      iconName = toLower(iconName);\n    }\n  }\n  if (!isStr(iconName) || iconName.trim() === '') {\n    return null;\n  }\n  // only allow alpha characters and dash\n  const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n  if (invalidChars !== '') {\n    return null;\n  }\n  return iconName;\n};\nconst getSrc = src => {\n  if (isStr(src)) {\n    src = src.trim();\n    if (isSrc(src)) {\n      return src;\n    }\n  }\n  return null;\n};\nconst isSrc = str => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = val => typeof val === 'string';\nconst toLower = val => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n/**\n * Returns `true` if the document or host element\n * has a `dir` set to `rtl`. The host value will always\n * take priority over the root document value.\n */\nconst isRTL = hostEl => {\n  if (hostEl) {\n    if (hostEl.dir !== '') {\n      return hostEl.dir.toLowerCase() === 'rtl';\n    }\n  }\n  return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === 'rtl';\n};\nexport { H, inheritAttributes as a, addIcons, getName as b, isRTL as c, Host as d, getUrl as g, getAssetPath, h, isStr as i, proxyCustomElement as p, render, setAssetPath, setNonce, setPlatformOptions };","map":{"version":3,"names":["NAMESPACE","BUILD","hydratedSelectorName","lazyLoad","updatable","__defProp","Object","defineProperty","__export","target","all","name","get","enumerable","getHostRef","ref","__stencil__getHostRef","registerHost","hostElement","cmpMeta","hostRef","$flags$","$hostElement$","$cmpMeta$","$instanceValues$","Map","$onReadyPromise$","Promise","r","$onReadyResolve$","isMemberInElement","elm","memberName","consoleError","e","el","console","error","styles","SLOT_FB_CSS","XLINK_NS","win","window","H","HTMLElement","plt","$resourcesUrl$","jmp","h2","raf","requestAnimationFrame","ael","eventName","listener","opts","addEventListener","rel","removeEventListener","ce","CustomEvent","promiseResolve","v","resolve","supportsConstructableStylesheets","CSSStyleSheet","replaceSync","queuePending","queueDomReads","queueDomWrites","queueTask","queue","write","cb","push","nextTick","flush","consume","i2","length","performance","now","then","writeTask","getAssetPath","path","assetUrl","URL","origin","location","href","pathname","setAssetPath","isComplexType","o","queryNonceMetaTagContent","doc","_a","_b","_c","head","querySelector","getAttribute","escapeRegExpSpecialCharacters","text","replace","result_exports","err","map","ok","unwrap","unwrapErr","value","isOk","isErr","result","fn","val","newVal","createStyleSheetIfNeededAndSupported","styles2","globalStyleSheet","createShadowRoot","shadowRoot","attachShadow","mode","adoptedStyleSheets","createTime","fnName","tagName","rootAppliedStyles","WeakMap","registerStyle","scopeId2","cssText","allowCS","style","set","addStyle","styleContainerNode","getScopeId","document","nodeType","appliedStyles","styleElm","Set","has","createElement","innerHTML","nonce","$nonce$","setAttribute","nodeName","preconnectLinks","querySelectorAll","referenceNode2","nextSibling","insertBefore","parentNode","stylesheet","unshift","existingStyleContainer","prepend","append","add","includes","attachStyles","flags","endAttachStyles","$tagName$","getRootNode","classList","cmp","h","vnodeData","children","child","key","simple","lastSimple","vNodeChildren","walk","c","Array","isArray","String","$text$","newVNode","classData","className","class","keys","filter","k","join","vnode","$attrs$","$children$","$key$","tag","$tag$","$elm$","Host","isHost","node","createSupportsRuleRe","selector","safeSelector2","RegExp","parsePropertyValue","propValue","propType","isFormAssociated","emitEvent","ev","dispatchEvent","setAccessor","oldValue","newValue","isSvg","initialRender","isProp","ln","toLowerCase","oldClasses","parseClassList","newClasses","remove","prop","removeProperty","setProperty","__lookupSetter__","slice","capture","endsWith","CAPTURE_EVENT_SUFFIX","CAPTURE_EVENT_REGEX","isComplex","n","xlink","removeAttributeNS","removeAttribute","setAttributeNS","parseClassListRegex","baseVal","split","updateElement","oldVnode","newVnode","isSvgMode2","isInitialRender","host","oldVnodeAttrs","newVnodeAttrs","sortedAttrNames","attrNames","attr","hostTagName","isSvgMode","createElm","oldParentVNode","newParentVNode","childIndex","newVNode2","childNode","createTextNode","Error","appendChild","addVnodes","parentElm","before","parentVNode","vnodes","startIdx","endIdx","containerElm","removeVnodes","index","nullifyVNodeRefs","updateChildren","oldCh","newCh","oldStartIdx","newStartIdx","idxInOld","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","elmToMove","isSameVnode","patch","leftVNode","rightVNode","oldVNode","oldChildren","newChildren","textContent","data","vNode","parent","newNode","reference","renderVdom","renderFnResults","isInitialLoad","hostElm","$vnode$","isHostElement","rootVnode","$attrsToReflect$","propName","attribute","hasAttribute","attachToAncestor","ancestorComponent","$onRenderResolve$","splice","scheduleUpdate","$ancestorComponent$","dispatch","dispatchHooks","endSchedule","instance","maybePromise","safeCall","enqueue","updateComponent","isPromisey","catch","err2","endUpdate","rc","endRender","callRender","childrenPromises","postUpdate","postUpdateComponent","render","endPostUpdate","addHydratedFlag","appDidLoad","who","detail","namespace","method","arg","getValue","setValue","oldVal","$members$","areBothNaN","Number","isNaN","didValueChange","$watchers$","watchMethods","watchMethodName","componentShouldUpdate","proxyComponent","Cstr","prototype","watchers","members","entries","memberFlags","origGetter","origSetter","getOwnPropertyDescriptor","apply","configurable","currentValue","attrNameToPropName","attributeChangedCallback","attrName","_a2","hasOwnProperty","flags2","entry","forEach","callbackName","call","propDesc","observedAttributes","from","_","m","initializeComponent","hmrVersionId","constructor","cmpTag","localName","customElements","whenDefined","endRegisterStyles","schedule","fireConnectedCallback","connectedCallback","endConnected","initializeNextTick","$lazyInstance$","disconnectedCallback","delete","proxyCustomElement","compactMeta","originalConnectedCallback","originalDisconnectedCallback","assign","__hasHostListenerAttached","__registerHost","__attachShadow","is","setNonce","setPlatformOptions","container","CACHED_MAP","getIconMap","Ionicons","addIcons","icons","addToIconMap","toKebabCase","existingIcon","undefined","warn","getUrl","i","url","getSrc","src","getName","icon","ios","md","getNamedUrl","iconName","iconEl","log","toLower","isSrc","isStr","trim","invalidChars","str","test","inheritAttributes","attributes","attributeObject","isRTL","hostEl","dir","a","b","d","g","p"],"sources":["C:/Users/dac19/Desktop/GymManagementSystem/frontend/node_modules/ionicons/components/index.js"],"sourcesContent":["const NAMESPACE = 'ionicons';\nconst BUILD = /* ionicons */ { hydratedSelectorName: \"hydrated\", lazyLoad: false, updatable: true};\n\n/*\n Stencil Client Platform v4.35.3 | MIT Licensed | https://stenciljs.com\n */\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/client/client-host-ref.ts\nvar getHostRef = (ref) => {\n  if (ref.__stencil__getHostRef) {\n    return ref.__stencil__getHostRef();\n  }\n  return void 0;\n};\nvar registerHost = (hostElement, cmpMeta) => {\n  const hostRef = {\n    $flags$: 0,\n    $hostElement$: hostElement,\n    $cmpMeta$: cmpMeta,\n    $instanceValues$: /* @__PURE__ */ new Map()\n  };\n  {\n    hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);\n    hostElement[\"s-p\"] = [];\n    hostElement[\"s-rc\"] = [];\n  }\n  const ref = hostRef;\n  hostElement.__stencil__getHostRef = () => ref;\n  return ref;\n};\nvar isMemberInElement = (elm, memberName) => memberName in elm;\nvar consoleError = (e, el) => (0, console.error)(e, el);\n\n// src/client/client-style.ts\nvar styles = /* @__PURE__ */ new Map();\nvar SLOT_FB_CSS = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\";\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\";\nvar win = typeof window !== \"undefined\" ? window : {};\nvar H = win.HTMLElement || class {\n};\nvar plt = {\n  $flags$: 0,\n  $resourcesUrl$: \"\",\n  jmp: (h2) => h2(),\n  raf: (h2) => requestAnimationFrame(h2),\n  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n  ce: (eventName, opts) => new CustomEvent(eventName, opts)\n};\nvar promiseResolve = (v) => Promise.resolve(v);\nvar supportsConstructableStylesheets = /* @__PURE__ */ (() => {\n  try {\n    new CSSStyleSheet();\n    return typeof new CSSStyleSheet().replaceSync === \"function\";\n  } catch (e) {\n  }\n  return false;\n})() ;\nvar queuePending = false;\nvar queueDomReads = [];\nvar queueDomWrites = [];\nvar queueTask = (queue, write) => (cb) => {\n  queue.push(cb);\n  if (!queuePending) {\n    queuePending = true;\n    if (write && plt.$flags$ & 4 /* queueSync */) {\n      nextTick(flush);\n    } else {\n      plt.raf(flush);\n    }\n  }\n};\nvar consume = (queue) => {\n  for (let i2 = 0; i2 < queue.length; i2++) {\n    try {\n      queue[i2](performance.now());\n    } catch (e) {\n      consoleError(e);\n    }\n  }\n  queue.length = 0;\n};\nvar flush = () => {\n  consume(queueDomReads);\n  {\n    consume(queueDomWrites);\n    if (queuePending = queueDomReads.length > 0) {\n      plt.raf(flush);\n    }\n  }\n};\nvar nextTick = (cb) => promiseResolve().then(cb);\nvar writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);\n\n// src/runtime/asset-path.ts\nvar getAssetPath = (path) => {\n  const assetUrl = new URL(path, plt.$resourcesUrl$);\n  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nvar setAssetPath = (path) => plt.$resourcesUrl$ = path;\nvar isComplexType = (o) => {\n  o = typeof o;\n  return o === \"object\" || o === \"function\";\n};\n\n// src/utils/query-nonce-meta-tag-content.ts\nfunction queryNonceMetaTagContent(doc) {\n  var _a, _b, _c;\n  return (_c = (_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name=\"csp-nonce\"]')) == null ? void 0 : _b.getAttribute(\"content\")) != null ? _c : void 0;\n}\n\n// src/utils/regular-expression.ts\nvar escapeRegExpSpecialCharacters = (text) => {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n};\n\n// src/utils/result.ts\nvar result_exports = {};\n__export(result_exports, {\n  err: () => err,\n  map: () => map,\n  ok: () => ok,\n  unwrap: () => unwrap,\n  unwrapErr: () => unwrapErr\n});\nvar ok = (value) => ({\n  isOk: true,\n  isErr: false,\n  value\n});\nvar err = (value) => ({\n  isOk: false,\n  isErr: true,\n  value\n});\nfunction map(result, fn) {\n  if (result.isOk) {\n    const val = fn(result.value);\n    if (val instanceof Promise) {\n      return val.then((newVal) => ok(newVal));\n    } else {\n      return ok(val);\n    }\n  }\n  if (result.isErr) {\n    const value = result.value;\n    return err(value);\n  }\n  throw \"should never get here\";\n}\nvar unwrap = (result) => {\n  if (result.isOk) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\nvar unwrapErr = (result) => {\n  if (result.isErr) {\n    return result.value;\n  } else {\n    throw result.value;\n  }\n};\n\n// src/utils/style.ts\nfunction createStyleSheetIfNeededAndSupported(styles2) {\n  return void 0;\n}\n\n// src/utils/shadow-root.ts\nvar globalStyleSheet;\nfunction createShadowRoot(cmpMeta) {\n  var _a;\n  const shadowRoot = this.attachShadow({ mode: \"open\" });\n  if (globalStyleSheet === void 0) globalStyleSheet = (_a = createStyleSheetIfNeededAndSupported()) != null ? _a : null;\n  if (globalStyleSheet) shadowRoot.adoptedStyleSheets.push(globalStyleSheet);\n}\nvar createTime = (fnName, tagName = \"\") => {\n  {\n    return () => {\n      return;\n    };\n  }\n};\nvar rootAppliedStyles = /* @__PURE__ */ new WeakMap();\nvar registerStyle = (scopeId2, cssText, allowCS) => {\n  let style = styles.get(scopeId2);\n  if (supportsConstructableStylesheets && allowCS) {\n    style = style || new CSSStyleSheet();\n    if (typeof style === \"string\") {\n      style = cssText;\n    } else {\n      style.replaceSync(cssText);\n    }\n  } else {\n    style = cssText;\n  }\n  styles.set(scopeId2, style);\n};\nvar addStyle = (styleContainerNode, cmpMeta, mode) => {\n  var _a;\n  const scopeId2 = getScopeId(cmpMeta);\n  const style = styles.get(scopeId2);\n  if (!win.document) {\n    return scopeId2;\n  }\n  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : win.document;\n  if (style) {\n    if (typeof style === \"string\") {\n      styleContainerNode = styleContainerNode.head || styleContainerNode;\n      let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n      let styleElm;\n      if (!appliedStyles) {\n        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());\n      }\n      if (!appliedStyles.has(scopeId2)) {\n        {\n          styleElm = win.document.createElement(\"style\");\n          styleElm.innerHTML = style;\n          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);\n          if (nonce != null) {\n            styleElm.setAttribute(\"nonce\", nonce);\n          }\n          if (!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */)) {\n            if (styleContainerNode.nodeName === \"HEAD\") {\n              const preconnectLinks = styleContainerNode.querySelectorAll(\"link[rel=preconnect]\");\n              const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector(\"style\");\n              styleContainerNode.insertBefore(\n                styleElm,\n                (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null\n              );\n            } else if (\"host\" in styleContainerNode) {\n              if (supportsConstructableStylesheets) {\n                const stylesheet = new CSSStyleSheet();\n                stylesheet.replaceSync(style);\n                styleContainerNode.adoptedStyleSheets.unshift(stylesheet);\n              } else {\n                const existingStyleContainer = styleContainerNode.querySelector(\"style\");\n                if (existingStyleContainer) {\n                  existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;\n                } else {\n                  styleContainerNode.prepend(styleElm);\n                }\n              }\n            } else {\n              styleContainerNode.append(styleElm);\n            }\n          }\n          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {\n            styleContainerNode.insertBefore(styleElm, null);\n          }\n        }\n        if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {\n          styleElm.innerHTML += SLOT_FB_CSS;\n        }\n        if (appliedStyles) {\n          appliedStyles.add(scopeId2);\n        }\n      }\n    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {\n      styleContainerNode.adoptedStyleSheets.push(style);\n    }\n  }\n  return scopeId2;\n};\nvar attachStyles = (hostRef) => {\n  const cmpMeta = hostRef.$cmpMeta$;\n  const elm = hostRef.$hostElement$;\n  const flags = cmpMeta.$flags$;\n  const endAttachStyles = createTime(\"attachStyles\", cmpMeta.$tagName$);\n  const scopeId2 = addStyle(\n    elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),\n    cmpMeta);\n  if (flags & 10 /* needsScopedEncapsulation */) {\n    elm[\"s-sc\"] = scopeId2;\n    elm.classList.add(scopeId2 + \"-h\");\n  }\n  endAttachStyles();\n};\nvar getScopeId = (cmp, mode) => \"sc-\" + (cmp.$tagName$);\nvar h = (nodeName, vnodeData, ...children) => {\n  let child = null;\n  let key = null;\n  let simple = false;\n  let lastSimple = false;\n  const vNodeChildren = [];\n  const walk = (c) => {\n    for (let i2 = 0; i2 < c.length; i2++) {\n      child = c[i2];\n      if (Array.isArray(child)) {\n        walk(child);\n      } else if (child != null && typeof child !== \"boolean\") {\n        if (simple = typeof nodeName !== \"function\" && !isComplexType(child)) {\n          child = String(child);\n        }\n        if (simple && lastSimple) {\n          vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n        } else {\n          vNodeChildren.push(simple ? newVNode(null, child) : child);\n        }\n        lastSimple = simple;\n      }\n    }\n  };\n  walk(children);\n  if (vnodeData) {\n    if (vnodeData.key) {\n      key = vnodeData.key;\n    }\n    {\n      const classData = vnodeData.className || vnodeData.class;\n      if (classData) {\n        vnodeData.class = typeof classData !== \"object\" ? classData : Object.keys(classData).filter((k) => classData[k]).join(\" \");\n      }\n    }\n  }\n  const vnode = newVNode(nodeName, null);\n  vnode.$attrs$ = vnodeData;\n  if (vNodeChildren.length > 0) {\n    vnode.$children$ = vNodeChildren;\n  }\n  {\n    vnode.$key$ = key;\n  }\n  return vnode;\n};\nvar newVNode = (tag, text) => {\n  const vnode = {\n    $flags$: 0,\n    $tag$: tag,\n    $text$: text,\n    $elm$: null,\n    $children$: null\n  };\n  {\n    vnode.$attrs$ = null;\n  }\n  {\n    vnode.$key$ = null;\n  }\n  return vnode;\n};\nvar Host = {};\nvar isHost = (node) => node && node.$tag$ === Host;\nvar createSupportsRuleRe = (selector) => {\n  const safeSelector2 = escapeRegExpSpecialCharacters(selector);\n  return new RegExp(\n    // First capture group: match any context before the selector that's not inside @supports selector()\n    // Using negative lookahead to avoid matching inside @supports selector(...) condition\n    `(^|[^@]|@(?!supports\\\\s+selector\\\\s*\\\\([^{]*?${safeSelector2}))(${safeSelector2}\\\\b)`,\n    \"g\"\n  );\n};\ncreateSupportsRuleRe(\"::slotted\");\ncreateSupportsRuleRe(\":host\");\ncreateSupportsRuleRe(\":host-context\");\nvar parsePropertyValue = (propValue, propType, isFormAssociated) => {\n  if (propValue != null && !isComplexType(propValue)) {\n    if (propType & 4 /* Boolean */) {\n      {\n        return propValue === \"false\" ? false : propValue === \"\" || !!propValue;\n      }\n    }\n    if (propType & 1 /* String */) {\n      return String(propValue);\n    }\n    return propValue;\n  }\n  return propValue;\n};\nvar emitEvent = (elm, name, opts) => {\n  const ev = plt.ce(name, opts);\n  elm.dispatchEvent(ev);\n  return ev;\n};\nvar setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {\n  if (oldValue === newValue) {\n    return;\n  }\n  let isProp = isMemberInElement(elm, memberName);\n  let ln = memberName.toLowerCase();\n  if (memberName === \"class\") {\n    const classList = elm.classList;\n    const oldClasses = parseClassList(oldValue);\n    let newClasses = parseClassList(newValue);\n    {\n      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n    }\n  } else if (memberName === \"style\") {\n    {\n      for (const prop in oldValue) {\n        if (!newValue || newValue[prop] == null) {\n          if (prop.includes(\"-\")) {\n            elm.style.removeProperty(prop);\n          } else {\n            elm.style[prop] = \"\";\n          }\n        }\n      }\n    }\n    for (const prop in newValue) {\n      if (!oldValue || newValue[prop] !== oldValue[prop]) {\n        if (prop.includes(\"-\")) {\n          elm.style.setProperty(prop, newValue[prop]);\n        } else {\n          elm.style[prop] = newValue[prop];\n        }\n      }\n    }\n  } else if (memberName === \"key\") ; else if (memberName === \"ref\") {\n    if (newValue) {\n      newValue(elm);\n    }\n  } else if ((!elm.__lookupSetter__(memberName)) && memberName[0] === \"o\" && memberName[1] === \"n\") {\n    if (memberName[2] === \"-\") {\n      memberName = memberName.slice(3);\n    } else if (isMemberInElement(win, ln)) {\n      memberName = ln.slice(2);\n    } else {\n      memberName = ln[2] + memberName.slice(3);\n    }\n    if (oldValue || newValue) {\n      const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);\n      memberName = memberName.replace(CAPTURE_EVENT_REGEX, \"\");\n      if (oldValue) {\n        plt.rel(elm, memberName, oldValue, capture);\n      }\n      if (newValue) {\n        plt.ael(elm, memberName, newValue, capture);\n      }\n    }\n  } else {\n    const isComplex = isComplexType(newValue);\n    if ((isProp || isComplex && newValue !== null) && true) {\n      try {\n        if (!elm.tagName.includes(\"-\")) {\n          const n = newValue == null ? \"\" : newValue;\n          if (memberName === \"list\") {\n            isProp = false;\n          } else if (oldValue == null || elm[memberName] != n) {\n            if (typeof elm.__lookupSetter__(memberName) === \"function\") {\n              elm[memberName] = n;\n            } else {\n              elm.setAttribute(memberName, n);\n            }\n          }\n        } else if (elm[memberName] !== newValue) {\n          elm[memberName] = newValue;\n        }\n      } catch (e) {\n      }\n    }\n    let xlink = false;\n    {\n      if (ln !== (ln = ln.replace(/^xlink\\:?/, \"\"))) {\n        memberName = ln;\n        xlink = true;\n      }\n    }\n    if (newValue == null || newValue === false) {\n      if (newValue !== false || elm.getAttribute(memberName) === \"\") {\n        if (xlink) {\n          elm.removeAttributeNS(XLINK_NS, memberName);\n        } else {\n          elm.removeAttribute(memberName);\n        }\n      }\n    } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex && elm.nodeType === 1 /* ElementNode */) {\n      newValue = newValue === true ? \"\" : newValue;\n      if (xlink) {\n        elm.setAttributeNS(XLINK_NS, memberName, newValue);\n      } else {\n        elm.setAttribute(memberName, newValue);\n      }\n    }\n  }\n};\nvar parseClassListRegex = /\\s/;\nvar parseClassList = (value) => {\n  if (typeof value === \"object\" && value && \"baseVal\" in value) {\n    value = value.baseVal;\n  }\n  if (!value || typeof value !== \"string\") {\n    return [];\n  }\n  return value.split(parseClassListRegex);\n};\nvar CAPTURE_EVENT_SUFFIX = \"Capture\";\nvar CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + \"$\");\n\n// src/runtime/vdom/update-element.ts\nvar updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {\n  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;\n  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};\n  const newVnodeAttrs = newVnode.$attrs$ || {};\n  {\n    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {\n      if (!(memberName in newVnodeAttrs)) {\n        setAccessor(\n          elm,\n          memberName,\n          oldVnodeAttrs[memberName],\n          void 0,\n          isSvgMode2,\n          newVnode.$flags$);\n      }\n    }\n  }\n  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {\n    setAccessor(\n      elm,\n      memberName,\n      oldVnodeAttrs[memberName],\n      newVnodeAttrs[memberName],\n      isSvgMode2,\n      newVnode.$flags$);\n  }\n};\nfunction sortedAttrNames(attrNames) {\n  return attrNames.includes(\"ref\") ? (\n    // we need to sort these to ensure that `'ref'` is the last attr\n    [...attrNames.filter((attr) => attr !== \"ref\"), \"ref\"]\n  ) : (\n    // no need to sort, return the original array\n    attrNames\n  );\n}\nvar hostTagName;\nvar isSvgMode = false;\nvar createElm = (oldParentVNode, newParentVNode, childIndex) => {\n  const newVNode2 = newParentVNode.$children$[childIndex];\n  let i2 = 0;\n  let elm;\n  let childNode;\n  if (newVNode2.$text$ !== null) {\n    elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);\n  } else {\n    if (!win.document) {\n      throw new Error(\n        \"You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.\"\n      );\n    }\n    elm = newVNode2.$elm$ = win.document.createElement(\n      newVNode2.$tag$\n    );\n    {\n      updateElement(null, newVNode2, isSvgMode);\n    }\n    if (newVNode2.$children$) {\n      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {\n        childNode = createElm(oldParentVNode, newVNode2, i2);\n        if (childNode) {\n          elm.appendChild(childNode);\n        }\n      }\n    }\n  }\n  elm[\"s-hn\"] = hostTagName;\n  return elm;\n};\nvar addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n  let containerElm = parentElm;\n  let childNode;\n  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n    containerElm = containerElm.shadowRoot;\n  }\n  for (; startIdx <= endIdx; ++startIdx) {\n    if (vnodes[startIdx]) {\n      childNode = createElm(null, parentVNode, startIdx);\n      if (childNode) {\n        vnodes[startIdx].$elm$ = childNode;\n        insertBefore(containerElm, childNode, before);\n      }\n    }\n  }\n};\nvar removeVnodes = (vnodes, startIdx, endIdx) => {\n  for (let index = startIdx; index <= endIdx; ++index) {\n    const vnode = vnodes[index];\n    if (vnode) {\n      const elm = vnode.$elm$;\n      nullifyVNodeRefs(vnode);\n      if (elm) {\n        elm.remove();\n      }\n    }\n  }\n};\nvar updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {\n  let oldStartIdx = 0;\n  let newStartIdx = 0;\n  let idxInOld = 0;\n  let i2 = 0;\n  let oldEndIdx = oldCh.length - 1;\n  let oldStartVnode = oldCh[0];\n  let oldEndVnode = oldCh[oldEndIdx];\n  let newEndIdx = newCh.length - 1;\n  let newStartVnode = newCh[0];\n  let newEndVnode = newCh[newEndIdx];\n  let node;\n  let elmToMove;\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (oldStartVnode == null) {\n      oldStartVnode = oldCh[++oldStartIdx];\n    } else if (oldEndVnode == null) {\n      oldEndVnode = oldCh[--oldEndIdx];\n    } else if (newStartVnode == null) {\n      newStartVnode = newCh[++newStartIdx];\n    } else if (newEndVnode == null) {\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {\n      patch(oldStartVnode, newStartVnode, isInitialRender);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {\n      patch(oldEndVnode, newEndVnode, isInitialRender);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {\n      patch(oldStartVnode, newEndVnode, isInitialRender);\n      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n      oldStartVnode = oldCh[++oldStartIdx];\n      newEndVnode = newCh[--newEndIdx];\n    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {\n      patch(oldEndVnode, newStartVnode, isInitialRender);\n      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);\n      oldEndVnode = oldCh[--oldEndIdx];\n      newStartVnode = newCh[++newStartIdx];\n    } else {\n      idxInOld = -1;\n      {\n        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {\n          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {\n            idxInOld = i2;\n            break;\n          }\n        }\n      }\n      if (idxInOld >= 0) {\n        elmToMove = oldCh[idxInOld];\n        if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);\n        } else {\n          patch(elmToMove, newStartVnode, isInitialRender);\n          oldCh[idxInOld] = void 0;\n          node = elmToMove.$elm$;\n        }\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);\n        newStartVnode = newCh[++newStartIdx];\n      }\n      if (node) {\n        {\n          insertBefore(oldStartVnode.$elm$.parentNode, node, oldStartVnode.$elm$);\n        }\n      }\n    }\n  }\n  if (oldStartIdx > oldEndIdx) {\n    addVnodes(\n      parentElm,\n      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,\n      newVNode2,\n      newCh,\n      newStartIdx,\n      newEndIdx\n    );\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n  }\n};\nvar isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {\n  if (leftVNode.$tag$ === rightVNode.$tag$) {\n    if (!isInitialRender) {\n      return leftVNode.$key$ === rightVNode.$key$;\n    }\n    if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {\n      leftVNode.$key$ = rightVNode.$key$;\n    }\n    return true;\n  }\n  return false;\n};\nvar patch = (oldVNode, newVNode2, isInitialRender = false) => {\n  const elm = newVNode2.$elm$ = oldVNode.$elm$;\n  const oldChildren = oldVNode.$children$;\n  const newChildren = newVNode2.$children$;\n  const text = newVNode2.$text$;\n  if (text === null) {\n    {\n      updateElement(oldVNode, newVNode2, isSvgMode);\n    }\n    if (oldChildren !== null && newChildren !== null) {\n      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);\n    } else if (newChildren !== null) {\n      if (oldVNode.$text$ !== null) {\n        elm.textContent = \"\";\n      }\n      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);\n    } else if (\n      // don't do this on initial render as it can cause non-hydrated content to be removed\n      !isInitialRender && BUILD.updatable && oldChildren !== null\n    ) {\n      removeVnodes(oldChildren, 0, oldChildren.length - 1);\n    } else ;\n  } else if (oldVNode.$text$ !== text) {\n    elm.data = text;\n  }\n};\nvar nullifyVNodeRefs = (vNode) => {\n  {\n    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);\n  }\n};\nvar insertBefore = (parent, newNode, reference) => {\n  {\n    return parent == null ? void 0 : parent.insertBefore(newNode, reference);\n  }\n};\nvar renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {\n  const hostElm = hostRef.$hostElement$;\n  const cmpMeta = hostRef.$cmpMeta$;\n  const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n  const isHostElement = isHost(renderFnResults);\n  const rootVnode = isHostElement ? renderFnResults : h(null, null, renderFnResults);\n  hostTagName = hostElm.tagName;\n  if (cmpMeta.$attrsToReflect$) {\n    rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n    cmpMeta.$attrsToReflect$.map(\n      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]\n    );\n  }\n  if (isInitialLoad && rootVnode.$attrs$) {\n    for (const key of Object.keys(rootVnode.$attrs$)) {\n      if (hostElm.hasAttribute(key) && ![\"key\", \"ref\", \"style\", \"class\"].includes(key)) {\n        rootVnode.$attrs$[key] = hostElm[key];\n      }\n    }\n  }\n  rootVnode.$tag$ = null;\n  rootVnode.$flags$ |= 4 /* isHost */;\n  hostRef.$vnode$ = rootVnode;\n  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm ;\n  patch(oldVNode, rootVnode, isInitialLoad);\n};\n\n// src/runtime/update-component.ts\nvar attachToAncestor = (hostRef, ancestorComponent) => {\n  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent[\"s-p\"]) {\n    const index = ancestorComponent[\"s-p\"].push(\n      new Promise(\n        (r) => hostRef.$onRenderResolve$ = () => {\n          ancestorComponent[\"s-p\"].splice(index - 1, 1);\n          r();\n        }\n      )\n    );\n  }\n};\nvar scheduleUpdate = (hostRef, isInitialLoad) => {\n  {\n    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;\n  }\n  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {\n    hostRef.$flags$ |= 512 /* needsRerender */;\n    return;\n  }\n  attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n  return writeTask(dispatch) ;\n};\nvar dispatchHooks = (hostRef, isInitialLoad) => {\n  const elm = hostRef.$hostElement$;\n  const endSchedule = createTime(\"scheduleUpdate\", hostRef.$cmpMeta$.$tagName$);\n  const instance = elm;\n  if (!instance) {\n    throw new Error(\n      `Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \\`externalRuntime: true\\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`\n    );\n  }\n  let maybePromise;\n  if (isInitialLoad) {\n    maybePromise = safeCall(instance, \"componentWillLoad\", void 0, elm);\n  } else {\n    maybePromise = safeCall(instance, \"componentWillUpdate\", void 0, elm);\n  }\n  maybePromise = enqueue(maybePromise, () => safeCall(instance, \"componentWillRender\", void 0, elm));\n  endSchedule();\n  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nvar enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch((err2) => {\n  console.error(err2);\n  fn();\n}) : fn();\nvar isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === \"function\";\nvar updateComponent = async (hostRef, instance, isInitialLoad) => {\n  var _a;\n  const elm = hostRef.$hostElement$;\n  const endUpdate = createTime(\"update\", hostRef.$cmpMeta$.$tagName$);\n  const rc = elm[\"s-rc\"];\n  if (isInitialLoad) {\n    attachStyles(hostRef);\n  }\n  const endRender = createTime(\"render\", hostRef.$cmpMeta$.$tagName$);\n  {\n    callRender(hostRef, instance, elm, isInitialLoad);\n  }\n  if (rc) {\n    rc.map((cb) => cb());\n    elm[\"s-rc\"] = void 0;\n  }\n  endRender();\n  endUpdate();\n  {\n    const childrenPromises = (_a = elm[\"s-p\"]) != null ? _a : [];\n    const postUpdate = () => postUpdateComponent(hostRef);\n    if (childrenPromises.length === 0) {\n      postUpdate();\n    } else {\n      Promise.all(childrenPromises).then(postUpdate);\n      hostRef.$flags$ |= 4 /* isWaitingForChildren */;\n      childrenPromises.length = 0;\n    }\n  }\n};\nvar callRender = (hostRef, instance, elm, isInitialLoad) => {\n  try {\n    instance = instance.render() ;\n    {\n      hostRef.$flags$ &= -17 /* isQueuedForUpdate */;\n    }\n    {\n      hostRef.$flags$ |= 2 /* hasRendered */;\n    }\n    {\n      {\n        {\n          renderVdom(hostRef, instance, isInitialLoad);\n        }\n      }\n    }\n  } catch (e) {\n    consoleError(e, hostRef.$hostElement$);\n  }\n  return null;\n};\nvar postUpdateComponent = (hostRef) => {\n  const tagName = hostRef.$cmpMeta$.$tagName$;\n  const elm = hostRef.$hostElement$;\n  const endPostUpdate = createTime(\"postUpdate\", tagName);\n  const instance = elm;\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  safeCall(instance, \"componentDidRender\", void 0, elm);\n  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {\n    hostRef.$flags$ |= 64 /* hasLoadedComponent */;\n    {\n      addHydratedFlag(elm);\n    }\n    safeCall(instance, \"componentDidLoad\", void 0, elm);\n    endPostUpdate();\n    {\n      hostRef.$onReadyResolve$(elm);\n      if (!ancestorComponent) {\n        appDidLoad();\n      }\n    }\n  } else {\n    safeCall(instance, \"componentDidUpdate\", void 0, elm);\n    endPostUpdate();\n  }\n  {\n    if (hostRef.$onRenderResolve$) {\n      hostRef.$onRenderResolve$();\n      hostRef.$onRenderResolve$ = void 0;\n    }\n    if (hostRef.$flags$ & 512 /* needsRerender */) {\n      nextTick(() => scheduleUpdate(hostRef, false));\n    }\n    hostRef.$flags$ &= -517;\n  }\n};\nvar appDidLoad = (who) => {\n  nextTick(() => emitEvent(win, \"appload\", { detail: { namespace: NAMESPACE } }));\n};\nvar safeCall = (instance, method, arg, elm) => {\n  if (instance && instance[method]) {\n    try {\n      return instance[method](arg);\n    } catch (e) {\n      consoleError(e, elm);\n    }\n  }\n  return void 0;\n};\nvar addHydratedFlag = (elm) => {\n  var _a;\n  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : \"hydrated\") ;\n};\n\n// src/runtime/set-value.ts\nvar getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nvar setValue = (ref, propName, newVal, cmpMeta) => {\n  const hostRef = getHostRef(ref);\n  const elm = ref;\n  const oldVal = hostRef.$instanceValues$.get(propName);\n  const flags = hostRef.$flags$;\n  const instance = elm;\n  newVal = parsePropertyValue(\n    newVal,\n    cmpMeta.$members$[propName][0]);\n  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n  const didValueChange = newVal !== oldVal && !areBothNaN;\n  if (didValueChange) {\n    hostRef.$instanceValues$.set(propName, newVal);\n    {\n      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {\n        const watchMethods = cmpMeta.$watchers$[propName];\n        if (watchMethods) {\n          watchMethods.map((watchMethodName) => {\n            try {\n              instance[watchMethodName](newVal, oldVal, propName);\n            } catch (e) {\n              consoleError(e, elm);\n            }\n          });\n        }\n      }\n      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {\n        if (instance.componentShouldUpdate) {\n          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n            return;\n          }\n        }\n        scheduleUpdate(hostRef, false);\n      }\n    }\n  }\n};\n\n// src/runtime/proxy-component.ts\nvar proxyComponent = (Cstr, cmpMeta, flags) => {\n  var _a, _b;\n  const prototype = Cstr.prototype;\n  if (cmpMeta.$members$ || (cmpMeta.$watchers$ || Cstr.watchers)) {\n    if (Cstr.watchers && !cmpMeta.$watchers$) {\n      cmpMeta.$watchers$ = Cstr.watchers;\n    }\n    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});\n    members.map(([memberName, [memberFlags]]) => {\n      if ((memberFlags & 31 /* Prop */ || memberFlags & 32 /* State */)) {\n        const { get: origGetter, set: origSetter } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};\n        if (origGetter) cmpMeta.$members$[memberName][0] |= 2048 /* Getter */;\n        if (origSetter) cmpMeta.$members$[memberName][0] |= 4096 /* Setter */;\n        {\n          Object.defineProperty(prototype, memberName, {\n            get() {\n              {\n                return origGetter ? origGetter.apply(this) : getValue(this, memberName);\n              }\n            },\n            configurable: true,\n            enumerable: true\n          });\n        }\n        Object.defineProperty(prototype, memberName, {\n          set(newValue) {\n            const ref = getHostRef(this);\n            if (origSetter) {\n              const currentValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              if (typeof currentValue === \"undefined\" && ref.$instanceValues$.get(memberName)) {\n                newValue = ref.$instanceValues$.get(memberName);\n              } else if (!ref.$instanceValues$.get(memberName) && currentValue) {\n                ref.$instanceValues$.set(memberName, currentValue);\n              }\n              origSetter.apply(this, [\n                parsePropertyValue(\n                  newValue,\n                  memberFlags)\n              ]);\n              newValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n            {\n              setValue(this, memberName, newValue, cmpMeta);\n              return;\n            }\n          }\n        });\n      }\n    });\n    {\n      const attrNameToPropName = /* @__PURE__ */ new Map();\n      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {\n        plt.jmp(() => {\n          var _a2;\n          const propName = attrNameToPropName.get(attrName);\n          if (this.hasOwnProperty(propName) && BUILD.lazyLoad) ; else if (prototype.hasOwnProperty(propName) && typeof this[propName] === \"number\" && // cast type to number to avoid TS compiler issues\n          this[propName] == newValue) {\n            return;\n          } else if (propName == null) {\n            const hostRef = getHostRef(this);\n            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;\n            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {\n              const elm = this;\n              const instance = elm;\n              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];\n              entry == null ? void 0 : entry.forEach((callbackName) => {\n                if (instance[callbackName] != null) {\n                  instance[callbackName].call(instance, newValue, oldValue, attrName);\n                }\n              });\n            }\n            return;\n          }\n          const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);\n          newValue = newValue === null && typeof this[propName] === \"boolean\" ? false : newValue;\n          if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {\n            this[propName] = newValue;\n          }\n        });\n      };\n      Cstr.observedAttributes = Array.from(\n        /* @__PURE__ */ new Set([\n          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),\n          ...members.filter(([_, m]) => m[0] & 15 /* HasAttribute */).map(([propName, m]) => {\n            var _a2;\n            const attrName = m[1] || propName;\n            attrNameToPropName.set(attrName, propName);\n            if (m[0] & 512 /* ReflectAttr */) {\n              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);\n            }\n            return attrName;\n          })\n        ])\n      );\n    }\n  }\n  return Cstr;\n};\n\n// src/runtime/initialize-component.ts\nvar initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {\n  let Cstr;\n  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {\n    hostRef.$flags$ |= 32 /* hasInitializedComponent */;\n    {\n      Cstr = elm.constructor;\n      const cmpTag = elm.localName;\n      customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);\n    }\n    if (Cstr && Cstr.style) {\n      let style;\n      if (typeof Cstr.style === \"string\") {\n        style = Cstr.style;\n      }\n      const scopeId2 = getScopeId(cmpMeta);\n      if (!styles.has(scopeId2)) {\n        const endRegisterStyles = createTime(\"registerStyles\", cmpMeta.$tagName$);\n        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));\n        endRegisterStyles();\n      }\n    }\n  }\n  const ancestorComponent = hostRef.$ancestorComponent$;\n  const schedule = () => scheduleUpdate(hostRef, true);\n  if (ancestorComponent && ancestorComponent[\"s-rc\"]) {\n    ancestorComponent[\"s-rc\"].push(schedule);\n  } else {\n    schedule();\n  }\n};\nvar fireConnectedCallback = (instance, elm) => {\n};\n\n// src/runtime/connected-callback.ts\nvar connectedCallback = (elm) => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    const hostRef = getHostRef(elm);\n    const cmpMeta = hostRef.$cmpMeta$;\n    const endConnected = createTime(\"connectedCallback\", cmpMeta.$tagName$);\n    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {\n      hostRef.$flags$ |= 1 /* hasConnected */;\n      {\n        let ancestorComponent = elm;\n        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {\n          if (ancestorComponent[\"s-p\"]) {\n            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);\n            break;\n          }\n        }\n      }\n      if (cmpMeta.$members$) {\n        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {\n            const value = elm[memberName];\n            delete elm[memberName];\n            elm[memberName] = value;\n          }\n        });\n      }\n      if (BUILD.initializeNextTick) {\n        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n      } else {\n        initializeComponent(elm, hostRef, cmpMeta);\n      }\n    } else {\n      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) ; else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {\n        hostRef.$onReadyPromise$.then(() => fireConnectedCallback());\n      }\n    }\n    endConnected();\n  }\n};\nvar disconnectedCallback = async (elm) => {\n  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {\n    getHostRef(elm);\n  }\n  if (rootAppliedStyles.has(elm)) {\n    rootAppliedStyles.delete(elm);\n  }\n  if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {\n    rootAppliedStyles.delete(elm.shadowRoot);\n  }\n};\nvar proxyCustomElement = (Cstr, compactMeta) => {\n  const cmpMeta = {\n    $flags$: compactMeta[0],\n    $tagName$: compactMeta[1]\n  };\n  {\n    cmpMeta.$members$ = compactMeta[2];\n  }\n  {\n    cmpMeta.$watchers$ = Cstr.$watchers$;\n  }\n  {\n    cmpMeta.$attrsToReflect$ = [];\n  }\n  const originalConnectedCallback = Cstr.prototype.connectedCallback;\n  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n  Object.assign(Cstr.prototype, {\n    __hasHostListenerAttached: false,\n    __registerHost() {\n      registerHost(this, cmpMeta);\n    },\n    connectedCallback() {\n      if (!this.__hasHostListenerAttached) {\n        getHostRef(this);\n        this.__hasHostListenerAttached = true;\n      }\n      connectedCallback(this);\n      if (originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    },\n    disconnectedCallback() {\n      disconnectedCallback(this);\n      if (originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    },\n    __attachShadow() {\n      {\n        if (!this.shadowRoot) {\n          createShadowRoot.call(this, cmpMeta);\n        } else {\n          if (this.shadowRoot.mode !== \"open\") {\n            throw new Error(\n              `Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`\n            );\n          }\n        }\n      }\n    }\n  });\n  Cstr.is = cmpMeta.$tagName$;\n  return proxyComponent(Cstr, cmpMeta);\n};\n\n// src/runtime/nonce.ts\nvar setNonce = (nonce) => plt.$nonce$ = nonce;\n\n// src/runtime/platform-options.ts\nvar setPlatformOptions = (opts) => Object.assign(plt, opts);\n\n// src/runtime/render.ts\nfunction render(vnode, container) {\n  const cmpMeta = {\n    $flags$: 0,\n    $tagName$: container.tagName\n  };\n  const ref = {\n    $cmpMeta$: cmpMeta,\n    $hostElement$: container\n  };\n  renderVdom(ref, vnode);\n}\n\nlet CACHED_MAP;\nconst getIconMap = () => {\n    if (typeof window === 'undefined') {\n        return new Map();\n    }\n    else {\n        if (!CACHED_MAP) {\n            const win = window;\n            win.Ionicons = win.Ionicons || {};\n            CACHED_MAP = win.Ionicons.map = win.Ionicons.map || new Map();\n        }\n        return CACHED_MAP;\n    }\n};\nconst addIcons = (icons) => {\n    Object.keys(icons).forEach((name) => {\n        addToIconMap(name, icons[name]);\n        /**\n         * Developers can also pass in the SVG object directly\n         * and Ionicons can map the object to a kebab case name.\n         * Example: addIcons({ addCircleOutline });\n         * This will create an \"addCircleOutline\" entry and\n         * an \"add-circle-outline\" entry.\n         * Usage: <ion-icon name=\"add-circle-outline\"></ion-icon>\n         * Using name=\"addCircleOutline\" is valid too, but the\n         * kebab case naming is preferred.\n         */\n        const toKebabCase = name.replace(/([a-z0-9]|(?=[A-Z]))([A-Z0-9])/g, '$1-$2').toLowerCase();\n        if (name !== toKebabCase) {\n            addToIconMap(toKebabCase, icons[name]);\n        }\n    });\n};\nconst addToIconMap = (name, data) => {\n    const map = getIconMap();\n    const existingIcon = map.get(name);\n    if (existingIcon === undefined) {\n        map.set(name, data);\n        /**\n         * Importing and defining the same icon reference\n         * multiple times should not yield a warning.\n         */\n    }\n    else if (existingIcon !== data) {\n        console.warn(`[Ionicons Warning]: Multiple icons were mapped to name \"${name}\". Ensure that multiple icons are not mapped to the same icon name.`);\n    }\n};\nconst getUrl = (i) => {\n    let url = getSrc(i.src);\n    if (url) {\n        return url;\n    }\n    url = getName(i.name, i.icon, i.mode, i.ios, i.md);\n    if (url) {\n        return getNamedUrl(url, i);\n    }\n    if (i.icon) {\n        url = getSrc(i.icon);\n        if (url) {\n            return url;\n        }\n        url = getSrc(i.icon[i.mode]);\n        if (url) {\n            return url;\n        }\n    }\n    return null;\n};\nconst getNamedUrl = (iconName, iconEl) => {\n    const url = getIconMap().get(iconName);\n    if (url) {\n        return url;\n    }\n    try {\n        return getAssetPath(`svg/${iconName}.svg`);\n    }\n    catch (e) {\n        console.log('e', e);\n        /**\n         * In the custom elements build version of ionicons, referencing an icon\n         * by name will throw an invalid URL error because the asset path is not defined.\n         * This catches that error and logs something that is more developer-friendly.\n         * We also include a reference to the ion-icon element so developers can\n         * figure out which instance of ion-icon needs to be updated.\n         */\n        console.warn(`[Ionicons Warning]: Could not load icon with name \"${iconName}\". Ensure that the icon is registered using addIcons or that the icon SVG data is passed directly to the icon component.`, iconEl);\n    }\n};\nconst getName = (iconName, icon, mode, ios, md) => {\n    // default to \"md\" if somehow the mode wasn't set\n    mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';\n    // if an icon was passed in using the ios or md attributes\n    // set the iconName to whatever was passed in\n    if (ios && mode === 'ios') {\n        iconName = toLower(ios);\n    }\n    else if (md && mode === 'md') {\n        iconName = toLower(md);\n    }\n    else {\n        if (!iconName && icon && !isSrc(icon)) {\n            iconName = icon;\n        }\n        if (isStr(iconName)) {\n            iconName = toLower(iconName);\n        }\n    }\n    if (!isStr(iconName) || iconName.trim() === '') {\n        return null;\n    }\n    // only allow alpha characters and dash\n    const invalidChars = iconName.replace(/[a-z]|-|\\d/gi, '');\n    if (invalidChars !== '') {\n        return null;\n    }\n    return iconName;\n};\nconst getSrc = (src) => {\n    if (isStr(src)) {\n        src = src.trim();\n        if (isSrc(src)) {\n            return src;\n        }\n    }\n    return null;\n};\nconst isSrc = (str) => str.length > 0 && /(\\/|\\.)/.test(str);\nconst isStr = (val) => typeof val === 'string';\nconst toLower = (val) => val.toLowerCase();\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `ion-input` should inherit\n * the `title` attribute that developers set directly on `ion-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n */\nconst inheritAttributes = (el, attributes = []) => {\n    const attributeObject = {};\n    attributes.forEach((attr) => {\n        if (el.hasAttribute(attr)) {\n            const value = el.getAttribute(attr);\n            if (value !== null) {\n                attributeObject[attr] = el.getAttribute(attr);\n            }\n            el.removeAttribute(attr);\n        }\n    });\n    return attributeObject;\n};\n/**\n * Returns `true` if the document or host element\n * has a `dir` set to `rtl`. The host value will always\n * take priority over the root document value.\n */\nconst isRTL = (hostEl) => {\n    if (hostEl) {\n        if (hostEl.dir !== '') {\n            return hostEl.dir.toLowerCase() === 'rtl';\n        }\n    }\n    return (document === null || document === void 0 ? void 0 : document.dir.toLowerCase()) === 'rtl';\n};\n\nexport { H, inheritAttributes as a, addIcons, getName as b, isRTL as c, Host as d, getUrl as g, getAssetPath, h, isStr as i, proxyCustomElement as p, render, setAssetPath, setNonce, setPlatformOptions };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}